# Fix for Subscribers Model Email Uniqueness Constraint

## Issue Description
The Subscribers model did not enforce a database-level uniqueness constraint on the email field. Although the subscription API checked for existing emails at the application layer, the absence of a uniqueness constraint at the database level could result in duplicate subscriber records due to:
- Concurrent requests
- Race conditions
- Direct database inserts
- Admin panel usage

## Changes Made

### 1. Model Update
**File**: `/home/voyager4/gsoc/EvalAI/apps/web/models.py`

Added `unique=True` constraint to the email field in the Subscribers model:

```python
class Subscribers(TimeStampedModel):
    """Model representing subbscribed user's email"""

    email = models.EmailField(max_length=70, unique=True)  # Added unique=True

    def __str__(self):
        return "{}".format(self.email)

    class Meta:
        app_label = "web"
        db_table = "subscribers"
        verbose_name_plural = "Subscribers"
```

### 2. Database Migration
**File**: `/home/voyager4/gsoc/EvalAI/apps/web/migrations/0011_add_unique_constraint_to_subscribers_email.py`

Created a new Django migration to add the unique constraint at the database level:

```python
# -*- coding: utf-8 -*-
# Generated by Django 2.2.20 on 2026-01-13 00:00
from __future__ import unicode_literals

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [("web", "0010_add_verbose_name_plural_for_subscribers_model")]

    operations = [
        migrations.AlterField(
            model_name="subscribers",
            name="email",
            field=models.EmailField(max_length=70, unique=True),
        )
    ]
```

### 3. Test Update
**File**: `/home/voyager4/gsoc/EvalAI/tests/unit/web/test_models.py`

Added test to verify the unique constraint works correctly:

```python
from django.db import IntegrityError  # Added import

class SubscribersTestCase(TestCase):
    def setUp(self):
        super(SubscribersTestCase, self).setUp()
        self.subscriber = Subscribers.objects.create(
            email="subscriber@domain.com"
        )

    def test__str__(self):
        self.assertEqual(str(self.subscriber), "subscriber@domain.com")

    def test_email_unique_constraint(self):  # New test
        """Test that duplicate email addresses raise IntegrityError"""
        with self.assertRaises(IntegrityError):
            Subscribers.objects.create(email="subscriber@domain.com")
```

## Benefits of This Fix

1. **Data Integrity**: Ensures no duplicate email addresses can exist in the database
2. **Race Condition Protection**: Database-level constraint prevents duplicates even with concurrent requests
3. **Admin Safety**: Prevents accidental duplicate creation through Django admin panel
4. **Direct Database Safety**: Protects against duplicates created through direct database operations

## Application-Level Check Still Beneficial

The existing application-level check in `/home/voyager4/gsoc/EvalAI/apps/web/views.py` (lines 161-165) is still valuable as it provides:
- Better user experience with custom error messages
- Prevents unnecessary database hits for duplicate attempts
- More graceful error handling in the API

The database constraint serves as a safety net to guarantee data integrity even if the application-level check fails or is bypassed.

## How to Apply the Migration

After these changes are merged, run the following command to apply the migration:

```bash
python manage.py migrate web
```

Or with Docker:

```bash
docker-compose run --rm django python manage.py migrate web
```

## Note on Existing Data

If there are existing duplicate email addresses in the database, the migration will fail. In that case, you would need to create a data migration to clean up duplicates before applying the unique constraint.

To check for existing duplicates:

```sql
SELECT email, COUNT(*) as count 
FROM subscribers 
GROUP BY email 
HAVING COUNT(*) > 1;
```

If duplicates exist, they should be resolved before running the migration.

